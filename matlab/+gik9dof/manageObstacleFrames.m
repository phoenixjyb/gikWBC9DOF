function summary = manageObstacleFrames(robot, obstacles, options)
%MANAGEOBSTACLEFRAMES Upsert obstacle frames onto the robot model.
%   summary = GIK9DOF.MANAGEOBSTACLEFRAMES(robot, obstacles) creates or
%   updates fixed-body frames representing obstacle poses. The function
%   expects each obstacle struct to contain either a 4x4 homogeneous
%   transform under the field `Pose` or positional/orientation fields that
%   can be converted into one.
%
%   Supported obstacle fields:
%       Name        - Unique frame name (optional, autogenerated if empty).
%       Pose        - 4x4 homogeneous transform (preferred).
%       Position    - 1x3 position vector (metres).
%       Orientation - Quaternion [w x y z] or [x y z w]; defaults to identity.
%       Center      - 1x2/1x3 centre coordinate (for floor-style obstacles).
%       Height      - Scalar z-offset used with Center when Pose omitted.
%
%   Options:
%       ParentBody  - Body to attach obstacles to (default robot.BaseName).
%
%   The returned summary mirrors the obstacle list and reports whether each
%   frame was created or updated.

arguments
    robot (1,1) rigidBodyTree
    obstacles (1,:) struct
    options.ParentBody (1,1) string = string(robot.BaseName)
end

summary = repmat(struct('Name', "", 'Action', "skipped", 'Pose', eye(4), 'Created', false), numel(obstacles), 1);

if isempty(obstacles)
    return
end

parentBody = char(options.ParentBody);

% Validate parent presence when not base.
if ~strcmp(parentBody, robot.BaseName)
    try
        robot.getBody(parentBody);
    catch
        error("gik9dof:manageObstacleFrames:UnknownParent", ...
            "Parent body '%s' not present in robot.", parentBody);
    end
end

existingNames = string(robot.BodyNames);

for idx = 1:numel(obstacles)
    spec = obstacles(idx);
    name = resolveName(spec, idx, existingNames);
    pose = resolvePose(spec);

    created = false;
    action = "updated";

    try
        body = robot.getBody(name);
        joint = body.Joint;
        if ~strcmp(body.Parent, parentBody)
            warning('gik9dof:manageObstacleFrames:MismatchedParent', ...
                'Obstacle "%s" already attached under ''%s''; expected parent ''%s''. Skipping update.', ...
                name, body.Parent, parentBody);
            action = "skipped";
        else
            setFixedTransform(joint, pose);
        end
    catch
        body = rigidBody(name);
        joint = rigidBodyJoint([name '_joint'], 'fixed');
        setFixedTransform(joint, pose);
        body.Joint = joint;
        addBody(robot, body, parentBody);
        created = true;
        action = "created";
        existingNames(end+1) = name; %#ok<AGROW>
    end

    summary(idx).Name = string(name);
    summary(idx).Action = action;
    summary(idx).Pose = pose;
    summary(idx).Created = created;
end

end

function name = resolveName(spec, idx, existingNames)
if isfield(spec, 'Name') && ~isempty(spec.Name)
    name = string(spec.Name);
elseif isfield(spec, 'name') && ~isempty(spec.name)
    name = string(spec.name);
else
    name = sprintf('obstacle_%d', idx);
end
name = matlab.lang.makeUniqueStrings(name, existingNames);
end

function pose = resolvePose(spec)
if isfield(spec, 'Pose') && ~isempty(spec.Pose)
    pose = validatePose(spec.Pose);
    return
end

if isfield(spec, 'pose') && ~isempty(spec.pose)
    pose = validatePose(spec.pose);
    return
end

if isfield(spec, 'Position') && ~isempty(spec.Position)
    position = double(spec.Position(:).');
else
    position = zeros(1,3);
    if isfield(spec, 'Center') && ~isempty(spec.Center)
        center = double(spec.Center(:).');
        if numel(center) >= 3
            position = center(1:3);
        elseif numel(center) >= 2
            z = extractHeight(spec);
            position = [center(1:2), z];
        end
    end
end

orientation = extractOrientation(spec);
pose = quat2tform(orientation);
pose(1:3,4) = position(1:3);
end

function pose = validatePose(candidate)
pose = double(candidate);
if ~isequal(size(pose), [4 4]) || ~all(isfinite(pose(:)))
    error('gik9dof:manageObstacleFrames:InvalidPose', ...
        'Obstacle poses must be finite 4x4 transforms.');
end
end

function quat = extractOrientation(spec)
if isfield(spec, 'Orientation') && ~isempty(spec.Orientation)
    raw = double(spec.Orientation(:).');
elseif isfield(spec, 'orientation') && ~isempty(spec.orientation)
    raw = double(spec.orientation(:).');
else
    quat = [1 0 0 0];
    return
end

if numel(raw) ~= 4
    error('gik9dof:manageObstacleFrames:InvalidOrientation', ...
        'Orientation must contain four elements.');
end

% Accept either [w x y z] or [x y z w]. If the last element has magnitude 1
% we assume MATLAB order; otherwise fall back to trailing scalar heuristic.
if abs(raw(1)) >= abs(raw(end))
    quat = raw;
else
    quat = [raw(end), raw(1:3)];
end

quat = quat / norm(quat);
end

function z = extractHeight(spec)
if isfield(spec, 'Height') && ~isempty(spec.Height)
    z = double(spec.Height);
elseif isfield(spec, 'height') && ~isempty(spec.height)
    z = double(spec.height);
else
    z = 0;
end
z = z(1);
end
