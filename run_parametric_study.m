%% Focused Parametric Study with Animation Generation
%  This script runs a focused parametric study with carefully selected
%  parameter combinations to explore the impact on path quality.
%  Each result is saved with full logs and animations are generated.
%
%  TODO: Migrate to unified config system (see UNIFIED_CONFIG_MIGRATION_COMPLETE.md)
%    New recommended approach:
%      cfg = gik9dof.loadPipelineProfile('default');
%      cfg.stage_b.hybrid_safety_margin = 0.10;  % Override as needed
%      log = gik9dof.trackReferenceTrajectory('PipelineConfig', cfg);
%    Benefits: Single source of truth, profile inheritance (aggressive/conservative)

clear; clc;
addpath(genpath('matlab'));

fprintf('=== Focused Parametric Study for Animation Review ===\n');
fprintf('Date: %s\n\n', datestr(now, 'yyyy-mm-dd HH:MM:SS'));

%% Configuration
STUDY_DIR = 'results/parametric_study_' + string(datetime('now', 'Format', 'yyyyMMdd_HHmmss'));
LOG_DIR = fullfile(STUDY_DIR, 'logs');
ANIM_DIR = fullfile(STUDY_DIR, 'animations');
mkdir(LOG_DIR);
mkdir(ANIM_DIR);

fprintf('Results will be saved to: %s\n\n', STUDY_DIR);

%% Define Test Configurations
% Carefully selected to test specific hypotheses:
% 1. Baseline (tuned params)
% 2. Very low safety margin (aggressive)
% 3. Very high safety margin (conservative)
% 4. Low lambda cusp (allow reversals)
% 5. High lambda cusp (penalize reversals)
% 6. High RS iterations (more smoothing attempts)
% 7. No reverse allowed
% 8. Fine clothoid discretization
% 9. Coarse clothoid discretization
% 10. Different Stage C lookaheads

configs = {};

% Config 1: BASELINE (Tuned Parameters)
configs{1} = struct( ...
    'name', 'Baseline_Tuned', ...
    'description', 'Current tuned parameters from Phase 1', ...
    'SafetyMargin', 0.10, ...
    'LambdaCusp', 1.0, ...
    'MaxRSIterations', 200, ...
    'AllowReverse', true, ...
    'ClothoidDiscretization', 0.08, ...
    'Lookahead', 0.8, ...
    'AccelLimit', 0.8, ...
    'HeadingKp', 1.0);

% Config 2: AGGRESSIVE (Low Safety, Low Lambda)
configs{2} = struct( ...
    'name', 'Aggressive_LowSafety', ...
    'description', 'Tight clearance, allow cusps', ...
    'SafetyMargin', 0.05, ...
    'LambdaCusp', 0.5, ...
    'MaxRSIterations', 200, ...
    'AllowReverse', true, ...
    'ClothoidDiscretization', 0.08, ...
    'Lookahead', 1.2, ...
    'AccelLimit', 1.2, ...
    'HeadingKp', 1.5);

% Config 3: CONSERVATIVE (High Safety, High Lambda)
configs{3} = struct( ...
    'name', 'Conservative_HighSafety', ...
    'description', 'Wide clearance, penalize cusps', ...
    'SafetyMargin', 0.20, ...
    'LambdaCusp', 3.0, ...
    'MaxRSIterations', 400, ...
    'AllowReverse', false, ...
    'ClothoidDiscretization', 0.05, ...
    'Lookahead', 0.6, ...
    'AccelLimit', 0.6, ...
    'HeadingKp', 0.8);

% Config 4: EXTREME ANTI-CUSP (Very High Lambda)
configs{4} = struct( ...
    'name', 'AntiCusp_HighLambda', ...
    'description', 'Extreme penalty on reversals', ...
    'SafetyMargin', 0.10, ...
    'LambdaCusp', 10.0, ...
    'MaxRSIterations', 600, ...
    'AllowReverse', true, ...
    'ClothoidDiscretization', 0.08, ...
    'Lookahead', 0.8, ...
    'AccelLimit', 0.8, ...
    'HeadingKp', 1.0);

% Config 5: EXTREME PRO-CUSP (Very Low Lambda)
configs{5} = struct( ...
    'name', 'ProCusp_LowLambda', ...
    'description', 'Minimal penalty on reversals', ...
    'SafetyMargin', 0.10, ...
    'LambdaCusp', 0.1, ...
    'MaxRSIterations', 200, ...
    'AllowReverse', true, ...
    'ClothoidDiscretization', 0.08, ...
    'Lookahead', 0.8, ...
    'AccelLimit', 0.8, ...
    'HeadingKp', 1.0);

% Config 6: HIGH RESOLUTION (Many RS iters, fine clothoid)
configs{6} = struct( ...
    'name', 'HighRes_FineSmooth', ...
    'description', 'Max smoothing attempts', ...
    'SafetyMargin', 0.10, ...
    'LambdaCusp', 1.5, ...
    'MaxRSIterations', 1000, ...
    'AllowReverse', true, ...
    'ClothoidDiscretization', 0.03, ...
    'Lookahead', 0.8, ...
    'AccelLimit', 0.8, ...
    'HeadingKp', 1.0);

% Config 7: NO REVERSE (Forward only)
configs{7} = struct( ...
    'name', 'ForwardOnly_NoReverse', ...
    'description', 'Disallow all reversals', ...
    'SafetyMargin', 0.10, ...
    'LambdaCusp', 1.0, ...
    'MaxRSIterations', 200, ...
    'AllowReverse', false, ...
    'ClothoidDiscretization', 0.08, ...
    'Lookahead', 0.8, ...
    'AccelLimit', 0.8, ...
    'HeadingKp', 1.0);

% Config 8: SHORT LOOKAHEAD (Reactive tracking)
configs{8} = struct( ...
    'name', 'ShortLookahead_Reactive', ...
    'description', 'Stage C short lookahead', ...
    'SafetyMargin', 0.10, ...
    'LambdaCusp', 1.0, ...
    'MaxRSIterations', 200, ...
    'AllowReverse', true, ...
    'ClothoidDiscretization', 0.08, ...
    'Lookahead', 0.4, ...
    'AccelLimit', 0.6, ...
    'HeadingKp', 1.2);

% Config 9: LONG LOOKAHEAD (Predictive tracking)
configs{9} = struct( ...
    'name', 'LongLookahead_Predictive', ...
    'description', 'Stage C long lookahead', ...
    'SafetyMargin', 0.10, ...
    'LambdaCusp', 1.0, ...
    'MaxRSIterations', 200, ...
    'AllowReverse', true, ...
    'ClothoidDiscretization', 0.08, ...
    'Lookahead', 1.5, ...
    'AccelLimit', 1.0, ...
    'HeadingKp', 0.8);

% Config 10: COARSE SMOOTHING (Fast but rough)
configs{10} = struct( ...
    'name', 'CoarseSmooth_Fast', ...
    'description', 'Coarse clothoid discretization', ...
    'SafetyMargin', 0.10, ...
    'LambdaCusp', 1.0, ...
    'MaxRSIterations', 100, ...
    'AllowReverse', true, ...
    'ClothoidDiscretization', 0.15, ...
    'Lookahead', 0.8, ...
    'AccelLimit', 0.8, ...
    'HeadingKp', 1.0);

nConfigs = length(configs);
fprintf('Parametric study: %d configurations\n', nConfigs);
fprintf('Estimated time: %.1f - %.1f minutes\n\n', nConfigs*0.8, nConfigs*1.5);

%% Run Each Configuration
results = [];

for i = 1:nConfigs
    cfg = configs{i};
    
    fprintf('\n========================================\n');
    fprintf('[%d/%d] %s\n', i, nConfigs, cfg.name);
    fprintf('========================================\n');
    fprintf('Description: %s\n', cfg.description);
    fprintf('Parameters:\n');
    fprintf('  Stage B: SM=%.2fm, LC=%.1f, Iters=%d, Reverse=%d, Clothoid=%.2fm\n', ...
            cfg.SafetyMargin, cfg.LambdaCusp, cfg.MaxRSIterations, ...
            cfg.AllowReverse, cfg.ClothoidDiscretization);
    fprintf('  Stage C: Lookahead=%.2fm, Accel=%.1f m/s², HeadingKp=%.1f\n', ...
            cfg.Lookahead, cfg.AccelLimit, cfg.HeadingKp);
    
    try
        % Run staged trajectory
        tic;
        runResult = gik9dof.runStagedReference( ...
            'ExecutionMode', 'pureIk', ...
            'SaveLog', false, ...
            'StageBHybridSafetyMargin', cfg.SafetyMargin, ...
            'StageBReedsSheppParams', struct( ...
                'lambdaCusp', cfg.LambdaCusp, ...
                'maxIterations', cfg.MaxRSIterations, ...
                'allowReverse', cfg.AllowReverse), ...
            'StageBUseReedsShepp', true, ...
            'StageBUseClothoid', true, ...
            'StageBClothoidParams', struct('discretization', cfg.ClothoidDiscretization), ...
            'StageBLookaheadDistance', cfg.Lookahead, ...
            'ChassisOverrides', struct( ...
                'accel_limit', cfg.AccelLimit, ...
                'heading_kp', cfg.HeadingKp));
        
        log = runResult.log;
        elapsedTime = toc;
        
        % Extract metrics
        stageC = log.stageLogs.stageC;
        stageB = log.stageLogs.stageB;
        
        metrics = struct();
        metrics.eeErrorMean = mean(stageC.positionErrorNorm);
        metrics.eeErrorMax = max(stageC.positionErrorNorm);
        metrics.cuspCount = stageB.diagnostics.cuspCount;
        metrics.pathSmoothness = stageB.diagnostics.pathSmoothness;
        metrics.rsImprovements = stageB.diagnostics.rsImprovements;
        metrics.rsAcceptanceRate = stageB.diagnostics.rsAcceptanceRate;
        metrics.runTime = elapsedTime;
        
        % Compute reference path jerk (Stage C)
        if isfield(stageC, 'referenceBaseStates')
            refBase = stageC.referenceBaseStates;
            dt = 0.1;
            dx = diff(refBase(:, 1)) / dt;
            dy = diff(refBase(:, 2)) / dt;
            velocity = sqrt(dx.^2 + dy.^2);
            accel = diff(velocity) / dt;
            jerk = diff(accel) / dt;
            metrics.refBaseJerkRMS = rms(jerk);
            metrics.refBaseJerkMax = max(abs(jerk));
        else
            metrics.refBaseJerkRMS = NaN;
            metrics.refBaseJerkMax = NaN;
        end
        
        fprintf('\n✓ Run completed in %.1f seconds\n', elapsedTime);
        fprintf('  Metrics:\n');
        fprintf('    EE Error: mean=%.4fm, max=%.4fm\n', metrics.eeErrorMean, metrics.eeErrorMax);
        fprintf('    Cusps: %d\n', metrics.cuspCount);
        fprintf('    Path Smoothness: %.3f\n', metrics.pathSmoothness);
        fprintf('    RS Improvements: %d (%.1f%% acceptance)\n', ...
                metrics.rsImprovements, metrics.rsAcceptanceRate * 100);
        fprintf('    Ref Base Jerk: RMS=%.1f m/s³, Max=%.1f m/s³\n', ...
                metrics.refBaseJerkRMS, metrics.refBaseJerkMax);
        
        % Save log
        logFile = fullfile(LOG_DIR, sprintf('%s.mat', cfg.name));
        save(logFile, 'log', 'cfg', 'metrics', '-v7.3');
        
        % Store result
        result = struct();
        result.config = cfg;
        result.log = log;
        result.metrics = metrics;
        result.logFile = logFile;
        result.success = true;
        
        results = [results; result]; %#ok<AGROW>
        
    catch ME
        fprintf('\n✗ ERROR: %s\n', ME.message);
        
        % Store failed result
        result = struct();
        result.config = cfg;
        result.log = [];
        result.metrics = struct();
        result.logFile = '';
        result.success = false;
        result.error = ME.message;
        
        results = [results; result]; %#ok<AGROW>
    end
end

%% Save Results Summary
resultsFile = fullfile(STUDY_DIR, 'parametric_study_results.mat');
save(resultsFile, 'results', 'configs', '-v7.3');

fprintf('\n\n========================================\n');
fprintf('Parametric Study Complete!\n');
fprintf('========================================\n');
fprintf('Results saved: %s\n', resultsFile);
fprintf('Successful runs: %d/%d\n', sum([results.success]), nConfigs);

%% Generate Summary Table
fprintf('\n=== Performance Summary ===\n');
fprintf('%-25s | EE Mean | EE Max  | Cusps | Jerk   | RS Acc\n', 'Config');
fprintf('%s\n', repmat('-', 1, 80));

for i = 1:length(results)
    if results(i).success
        m = results(i).metrics;
        fprintf('%-25s | %.4f  | %.4f  | %5d | %6.1f | %5.1f%%\n', ...
                results(i).config.name, ...
                m.eeErrorMean, m.eeErrorMax, m.cuspCount, ...
                m.refBaseJerkRMS, m.rsAcceptanceRate * 100);
    else
        fprintf('%-25s | FAILED\n', results(i).config.name);
    end
end

fprintf('\n=== Next Step ===\n');
fprintf('Run: generate_parametric_animations\n');
fprintf('This will create animations for all successful configs.\n');
