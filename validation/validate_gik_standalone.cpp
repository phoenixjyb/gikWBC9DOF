/**
 * @file validate_gik_standalone.cpp
 * @brief Standalone C++ validation program for GIK solver (no ROS2 dependency)
 * 
 * This program:
 * 1. Loads test cases from JSON file (generated by MATLAB)
 * 2. Calls the generated GIK C++ solver for each test case
 * 3. Compares results with MATLAB reference solutions
 * 4. Outputs validation results as JSON
 * 
 * Build (WSL/Linux):
 *   g++ -std=c++17 -O2 -o validate_gik_standalone validate_gik_standalone.cpp \
 *       -I../codegen/gik9dof_arm64_20constraints \
 *       -L../codegen/gik9dof_arm64_20constraints \
 *       -lgik9dof_codegen_inuse_solveGIKStepWrapper \
 *       -lm -lstdc++ -lpthread
 * 
 * Run:
 *   ./validate_gik_standalone gik_test_cases.json
 */

#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <string>
#include <chrono>
#include <cmath>
#include <iomanip>
#include <algorithm>

// MATLAB Coder generated GIK solver
// R2024a with Methods interface still generates GIKSolver class
#include "GIKSolver.h"
#include "solveGIKStepWrapper_types.h"

// Simple JSON library (header-only)
#include "json_simple.hpp"

using namespace std;
using json = nlohmann::json;

// ============================================================================
// Helper Functions
// ============================================================================

/**
 * @brief Compute L2 norm of difference between two vectors
 */
double vectorDiffNorm(const double* v1, const double* v2, int size) {
    double sumSq = 0.0;
    for (int i = 0; i < size; i++) {
        double diff = v1[i] - v2[i];
        sumSq += diff * diff;
    }
    return sqrt(sumSq);
}

/**
 * @brief Compute max absolute difference between two vectors
 */
double vectorDiffMax(const double* v1, const double* v2, int size) {
    double maxDiff = 0.0;
    for (int i = 0; i < size; i++) {
        double diff = fabs(v1[i] - v2[i]);
        if (diff > maxDiff) {
            maxDiff = diff;
        }
    }
    return maxDiff;
}

/**
 * @brief Print vector to console
 */
void printVector(const char* label, const double* vec, int size) {
    cout << label << " [";
    for (int i = 0; i < size; i++) {
        cout << fixed << setprecision(4) << vec[i];
        if (i < size - 1) cout << ", ";
    }
    cout << "]" << endl;
}

/**
 * @brief Load JSON file
 */
json loadJsonFile(const string& filename) {
    ifstream file(filename);
    if (!file.is_open()) {
        throw runtime_error("Could not open file: " + filename);
    }
    json data;
    file >> data;
    file.close();
    return data;
}

/**
 * @brief Save JSON file
 */
void saveJsonFile(const string& filename, const json& data) {
    ofstream file(filename);
    if (!file.is_open()) {
        throw runtime_error("Could not create file: " + filename);
    }
    file << setw(2) << data << endl;
    file.close();
}

// ============================================================================
// Test Case Structure
// ============================================================================

struct TestCaseInput {
    int id;
    int waypointIndex;
    
    // Input arrays
    double qCurrent[9];
    double targetPose[16];
    int distBodyIndices[20];
    int distRefBodyIndices[20];
    double distBoundsLower[20];
    double distBoundsUpper[20];
    double distWeights[20];
    
    // MATLAB reference
    double qNext_matlab[9];
    bool matlab_success;
    double matlab_solveTime_ms;
    int matlab_iterations;
    string matlab_status;
};

struct TestCaseResult {
    int id;
    int waypointIndex;
    
    // C++ solver output
    double qNext_cpp[9];
    bool cpp_success;
    double cpp_solveTime_ms;
    int cpp_iterations;
    string cpp_status;
    
    // Comparison metrics
    double qDiff_L2;          // L2 norm of joint angle difference
    double qDiff_max;         // Max absolute joint angle difference
    bool withinTolerance;     // Overall pass/fail
    
    // Tolerances
    static constexpr double JOINT_TOLERANCE_L2 = 0.01;  // 0.01 rad (~0.57 deg)
    static constexpr double JOINT_TOLERANCE_MAX = 0.02; // 0.02 rad (~1.15 deg)
};

// ============================================================================
// Test Case Loading
// ============================================================================

vector<TestCaseInput> loadTestCases(const string& jsonFile) {
    cout << "Loading test cases from: " << jsonFile << endl;
    
    json data = loadJsonFile(jsonFile);
    vector<TestCaseInput> testCases;
    
    // Parse metadata
    if (data.contains("metadata")) {
        auto meta = data["metadata"];
        cout << "  Source: " << meta.value("sourceFile", "unknown") << endl;
        cout << "  Test cases: " << meta.value("numTestCases", 0) << endl;
        cout << "  Total waypoints: " << meta.value("totalWaypoints", 0) << endl;
    }
    
    // Parse test cases
    if (!data.contains("testCases")) {
        throw runtime_error("JSON file missing 'testCases' field");
    }
    
    for (const auto& tc : data["testCases"]) {
        TestCaseInput testCase;
        
        testCase.id = tc.value("id", 0);
        testCase.waypointIndex = tc.value("waypointIndex", 0);
        
        // Input data
        auto input = tc["input"];
        
        // qCurrent (9x1)
        auto qCurr = input["qCurrent"];
        for (int i = 0; i < 9; i++) {
            testCase.qCurrent[i] = qCurr[i];
        }
        
        // targetPose (4x4, row-major in JSON, column-major in C++)
        auto tPose = input["targetPose"];
        for (int row = 0; row < 4; row++) {
            for (int col = 0; col < 4; col++) {
                testCase.targetPose[col * 4 + row] = tPose[row][col];
            }
        }
        
        // Distance constraints
        auto dBodyIdx = input["distBodyIndices"];
        auto dRefBodyIdx = input["distRefBodyIndices"];
        auto dLower = input["distBoundsLower"];
        auto dUpper = input["distBoundsUpper"];
        auto dWeights = input["distWeights"];
        
        for (int i = 0; i < 20; i++) {
            testCase.distBodyIndices[i] = dBodyIdx[i];
            testCase.distRefBodyIndices[i] = dRefBodyIdx[i];
            testCase.distBoundsLower[i] = dLower[i];
            testCase.distBoundsUpper[i] = dUpper[i];
            testCase.distWeights[i] = dWeights[i];
        }
        
        // MATLAB reference
        auto matlabRef = tc["matlab_reference"];
        auto qNext_mat = matlabRef["qNext"];
        for (int i = 0; i < 9; i++) {
            testCase.qNext_matlab[i] = qNext_mat[i];
        }
        
        testCase.matlab_success = matlabRef.value("success", false);
        testCase.matlab_solveTime_ms = matlabRef.value("solveTime_ms", 0.0);
        testCase.matlab_iterations = matlabRef.value("iterations", 0);
        testCase.matlab_status = matlabRef.value("status", "unknown");
        
        testCases.push_back(testCase);
    }
    
    cout << "  Loaded " << testCases.size() << " test cases" << endl << endl;
    return testCases;
}

// ============================================================================
// Test Execution
// ============================================================================

TestCaseResult runTestCase(const TestCaseInput& input) {
    TestCaseResult result;
    result.id = input.id;
    result.waypointIndex = input.waypointIndex;
    
    // Prepare output arrays
    double qNext[9];
    gik9dof::struct0_T solverInfo;
    
    // Create static solver instance (class-based API, MaxIterations=1000)
    static gik9dof::GIKSolver solver;
    
    // Call C++ solver
    auto start = chrono::high_resolution_clock::now();
    
    solver.solveGIKStepWrapper(
        input.qCurrent,
        input.targetPose,
        input.distBodyIndices,
        input.distRefBodyIndices,
        input.distBoundsLower,
        input.distBoundsUpper,
        input.distWeights,
        qNext,
        &solverInfo
    );
    
    auto end = chrono::high_resolution_clock::now();
    result.cpp_solveTime_ms = chrono::duration<double, milli>(end - start).count();
    
    // Extract solver info
    result.cpp_iterations = solverInfo.Iterations;
    
    // Convert status to string (bounded_array has data[] and size[] members)
    // Status is bounded_array<char, 14U, 2U>, so size[0] is the actual string length
    int statusLen = std::min((int)solverInfo.Status.size[0], 14);
    result.cpp_status = string(solverInfo.Status.data, statusLen);
    
    result.cpp_success = (result.cpp_status == "success");
    
    // Copy results
    for (int i = 0; i < 9; i++) {
        result.qNext_cpp[i] = qNext[i];
    }
    
    // Compute comparison metrics
    result.qDiff_L2 = vectorDiffNorm(qNext, input.qNext_matlab, 9);
    result.qDiff_max = vectorDiffMax(qNext, input.qNext_matlab, 9);
    
    // Check tolerances
    result.withinTolerance = (result.qDiff_L2 < TestCaseResult::JOINT_TOLERANCE_L2) &&
                             (result.qDiff_max < TestCaseResult::JOINT_TOLERANCE_MAX);
    
    return result;
}

// ============================================================================
// Results Output
// ============================================================================

void printTestResult(const TestCaseResult& result, bool verbose = true) {
    cout << "Test " << result.id << " (waypoint " << result.waypointIndex << "): ";
    
    if (result.withinTolerance) {
        cout << "âœ“ PASS";
    } else {
        cout << "âœ— FAIL";
    }
    
    cout << " | L2=" << fixed << setprecision(5) << result.qDiff_L2
         << " | max=" << result.qDiff_max
         << " | " << result.cpp_solveTime_ms << " ms"
         << " | " << result.cpp_iterations << " iters" << endl;
    
    if (verbose && !result.withinTolerance) {
        cout << "  MATLAB: "; printVector("", result.qNext_cpp, 9);
        cout << "  C++:    "; printVector("", result.qNext_cpp, 9);
    }
}

void saveResults(const string& outputFile, const vector<TestCaseResult>& results) {
    json output;
    
    // Metadata
    output["metadata"]["testDate"] = "2025-10-08";
    output["metadata"]["numTests"] = results.size();
    output["metadata"]["jointToleranceL2"] = TestCaseResult::JOINT_TOLERANCE_L2;
    output["metadata"]["jointToleranceMax"] = TestCaseResult::JOINT_TOLERANCE_MAX;
    
    // Count passes/fails
    int numPass = 0, numFail = 0;
    for (const auto& r : results) {
        if (r.withinTolerance) numPass++;
        else numFail++;
    }
    output["metadata"]["numPassed"] = numPass;
    output["metadata"]["numFailed"] = numFail;
    
    // Individual results
    output["results"] = json::array();
    for (const auto& r : results) {
        json res;
        res["id"] = r.id;
        res["waypointIndex"] = r.waypointIndex;
        res["cpp_success"] = r.cpp_success;
        res["cpp_solveTime_ms"] = r.cpp_solveTime_ms;
        res["cpp_iterations"] = r.cpp_iterations;
        res["cpp_status"] = r.cpp_status;
        res["qNext_cpp"] = vector<double>(r.qNext_cpp, r.qNext_cpp + 9);
        res["qDiff_L2"] = r.qDiff_L2;
        res["qDiff_max"] = r.qDiff_max;
        res["withinTolerance"] = r.withinTolerance;
        
        output["results"].push_back(res);
    }
    
    saveJsonFile(outputFile, output);
    cout << "\nResults saved to: " << outputFile << endl;
}

// ============================================================================
// Main
// ============================================================================

int main(int argc, char** argv) {
    cout << "========================================" << endl;
    cout << "GIK C++ Standalone Validation" << endl;
    cout << "========================================" << endl << endl;
    
    // Parse arguments
    string inputFile = "gik_test_cases.json";
    string outputFile = "gik_validation_results.json";
    
    if (argc > 1) {
        inputFile = argv[1];
    }
    if (argc > 2) {
        outputFile = argv[2];
    }
    
    try {
        // Load test cases
        vector<TestCaseInput> testCases = loadTestCases(inputFile);
        
        // Run tests
        cout << "Running " << testCases.size() << " test cases..." << endl;
        cout << "----------------------------------------" << endl;
        
        vector<TestCaseResult> results;
        for (const auto& tc : testCases) {
            TestCaseResult result = runTestCase(tc);
            results.push_back(result);
            printTestResult(result, false);
        }
        
        // Summary
        cout << "----------------------------------------" << endl;
        int numPass = count_if(results.begin(), results.end(), 
                               [](const TestCaseResult& r) { return r.withinTolerance; });
        int numFail = results.size() - numPass;
        
        cout << "\nSummary:" << endl;
        cout << "  Total tests: " << results.size() << endl;
        cout << "  Passed: " << numPass << " âœ“" << endl;
        cout << "  Failed: " << numFail << " âœ—" << endl;
        
        if (numFail == 0) {
            cout << "\nðŸŽ‰ All tests PASSED!" << endl;
        } else {
            cout << "\nâš  Some tests FAILED!" << endl;
        }
        
        // Save results
        saveResults(outputFile, results);
        
        // No cleanup needed - static GIKSolver destructor handles it
        
        return (numFail == 0) ? 0 : 1;
        
    } catch (const exception& e) {
        cerr << "\nâŒ Error: " << e.what() << endl;
        return 1;
    }
}
